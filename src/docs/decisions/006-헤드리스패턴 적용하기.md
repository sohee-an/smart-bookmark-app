# 📚 헤드리스 컴포넌트 설계 사전 학습

> Input 컴포넌트 헤드리스 리팩토링 + Storybook 도입 전 개념 정리  
> `components/ui/input` 리팩토링 시작 전 작성

---

## 왜 이걸 공부했나

shadcn의 GitHub 소스를 보다가 Radix UI(헤드리스)를 한 번 더 감싸서 스타일을 입히는 구조를 발견했다. 기존 `Input` 컴포넌트가 로직과 스타일이 섞여있어서 디자인이 바뀌면 같이 수정해야 하는 구조였고, 이를 개선하기 위해 헤드리스 패턴을 직접 적용하기로 결정했다.

---

## 1. 헤드리스 패턴이 나온 이유

### 핵심 문제

```
"스타일은 다른데 동작은 같은 컴포넌트가 필요하다"

토스 버튼   → 토스 디자인 + 클릭 로직
내 서비스   → 내 디자인  + 클릭 로직 (로직은 동일)
```

매번 로직을 새로 짜는 건 비효율적이고, 그렇다고 스타일을 강제하는 라이브러리를 쓰면 커스텀이 어렵다.

### 헤드리스 패턴의 해결 방식

```
로직/접근성 레이어 (headless)
    ↓ 소비자가 스타일 입힘
스타일 레이어 (styled)
```

Radix UI, Headless UI가 이 방식. shadcn은 Radix UI에 Tailwind를 입힌 래퍼.

### 내 Input에 적용하면

```
기존
  Input.tsx → 로직 + 스타일 + 구조 다 섞임

분리 후
  useInput.ts          → 로직만 (id 생성, 에러 상태, aria 속성)
  InputPrimitive.tsx   → 구조만 (label slot, icon slot, error slot)
  Input.tsx            → 스타일 입힌 완성본
```

### 구현해가는 과정

```ts
질문: id, hasError를 그냥 props로 내리면 안 됐나?

생각해봐요.
InputLabel이 htmlFor에 id가 필요하고
InputField도 id가 필요하고
InputError도 id가 필요해요

→ 3군데 다 props로 내리면?
→ 매번 사용자가 id를 직접 전달해야 함
→ Context로 Root에서 한 번만 만들고 공유

```

---

## 2. Compound Component 패턴

헤드리스 라이브러리들이 공통으로 쓰는 조립 방식이다.

### 기본 구조

```tsx
// 소비자 입장에서 이렇게 조립
<Input.Root>
  <Input.Label />
  <Input.Field />
  <Input.ErrorMessage />
</Input.Root>
```

### 내부 동작 원리

Context로 상태를 공유하고 각 부품이 알아서 읽어간다.

```tsx
// Root가 Context 제공
const InputContext = createContext<InputContextValue>(null);

function InputRoot({ children, ...props }) {
  const id = useId();
  const [hasError, setHasError] = useState(false);

  return <InputContext.Provider value={{ id, hasError }}>{children}</InputContext.Provider>;
}

// 각 부품이 Context에서 읽음
function InputLabel({ children }) {
  const { id } = useContext(InputContext);
  return <label htmlFor={id}>{children}</label>;
}

function InputField(props) {
  const { id, hasError } = useContext(InputContext);
  return <input id={id} aria-invalid={hasError} {...props} />;
}
```

### 장점

```
디자인 변경 → 스타일 레이어만 수정
로직 변경   → InputPrimitive만 수정
서로 영향 없음
```

---

## 3. forwardRef를 써야 하는 이유

기존 코드에 있었지만 왜 쓰는지 정확히 이해하지 못했다.

### 문제

```tsx
// 부모가 input DOM에 직접 접근하고 싶을 때
const inputRef = useRef<HTMLInputElement>(null)
<Input ref={inputRef} />

// forwardRef 없으면 ref가 전달 안 됨 → 접근 불가
```

### 해결

```tsx
export const Input = forwardRef<HTMLInputElement, InputProps>((props, ref) => {
  return <input ref={ref} {...props} />;
});
```

### react-hook-form과의 연결

```tsx
// register가 내부적으로 ref를 통해 DOM에 접근함
const { register } = useForm()

<Input {...register('email')} />
// register가 반환하는 것: { ref, onChange, onBlur, name }
// → forwardRef 없으면 ref 전달 안 됨 → react-hook-form 동작 안 함
```

**결론: 공통 Input 컴포넌트는 항상 forwardRef로 만들어야 한다.**

---

## 4. Storybook 기본 개념

### Story란

컴포넌트의 "상태 스냅샷"이다. 하나의 컴포넌트가 가질 수 있는 모든 경우의 수를 문서화한다.

```tsx
// Input.stories.tsx
export default {
  title: "UI/Input",
  component: Input,
};

// 각 Story = 하나의 케이스
export const Default = {};

export const WithError = {
  args: { error: "이메일 형식이 올바르지 않습니다." },
};

export const WithIcon = {
  args: { icon: <MailIcon /> },
};

export const Disabled = {
  args: { disabled: true },
};
```

### 체크해야 할 Story 케이스 (Input 기준)

```
Default          → 기본 상태
WithLabel        → label 있는 경우
WithIcon         → 아이콘 있는 경우
WithError        → 에러 메시지 있는 경우
Disabled         → 비활성화
Focus            → 포커스 상태
ErrorWithIcon    → 아이콘 + 에러 동시
```

### args와 controls

```tsx
export default {
  argTypes: {
    error: { control: "text" }, // Storybook UI에서 직접 수정 가능
    disabled: { control: "boolean" },
  },
};
```

Storybook UI에서 실시간으로 props를 바꿔보면서 테스트할 수 있다.

---

## 5. 접근성 (a11y) 기본

헤드리스 컴포넌트의 핵심 존재 이유 중 하나다.

### Input에 필요한 aria 속성들

```tsx
<label htmlFor={id}>         // label 클릭 → input 포커스
<input
  id={id}
  aria-invalid={hasError}    // 스크린리더에 에러 상태 알림
  aria-describedby={errorId} // 에러 메시지 ID 연결
/>
<p id={errorId}>             // 에러 메시지
  {error}
</p>
```

### 왜 중요한가

```
토스, 카카오 같은 기업은 접근성을 코드 리뷰 체크리스트에 포함시킨다.
시각 장애인도 키보드만으로 폼을 사용할 수 있어야 한다.
스크린리더가 에러를 읽어줄 수 있어야 한다.
```

---

## 6. 분리 전/후 비교

### 분리 전 (현재)

```tsx
// components/ui/input.tsx
// 로직 + 스타일 + 구조 다 섞임 (약 70줄)
export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ icon, label, error, className, ...props }, ref) => {
    const id = useId();
    const hasError = !!error;

    return (
      <div className="relative w-full space-y-1.5">
        {" "}
        {/* 구조 */}
        <label className="sr-only">...</label> {/* 구조 + 스타일 */}
        <input className="rounded-2xl border-2 ..." /> {/* 스타일 */}
        <p className="text-red-500">...</p> {/* 스타일 */}
      </div>
    );
  }
);
```

### 분리 후 (목표)

```
components/ui/input/
  ├── input.primitive.tsx   ← 구조 + 로직 + 접근성
  ├── input.tsx             ← 스타일 입힌 완성본
  ├── input.stories.tsx     ← Storybook
  └── index.ts              ← export
```

---

## 학습 우선순위

```
지금 당장 (코드 치기 전)
  ✅ forwardRef 이유
  ✅ Compound Component 개념
  ✅ aria-invalid, aria-describedby

Storybook 셋업 전
  ✅ Story 파일 구조
  ✅ args / argTypes / controls

여유 있을 때
  Radix UI Input 소스 코드 읽기
  Headless UI 소스 코드 읽기
```

---

## 참고

- [Radix UI Primitives](https://www.radix-ui.com/primitives) — 헤드리스 패턴 레퍼런스
- [shadcn/ui GitHub](https://github.com/shadcn-ui/ui) — 헤드리스 위에 스타일 입히는 방식
- [Storybook 공식문서 - Writing Stories](https://storybook.js.org/docs/writing-stories)
- [MDN - ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) — 접근성 속성 레퍼런스
  fl
